<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>This Big — by OPULENT HARDWARE</title>
<style>
  :root{
    /* Fixed light theme */
    --paper:#e9f5ef;            /* mint-green paper (no dots) */
    --ink:#17221c;
    --muted:#5a6d63;
    --accent:#18a34a;           /* measure color */
    --shadow:rgba(16,24,16,.18);
    --card:#ffffff;
    color-scheme: light;        /* don’t follow OS/Browser dark mode */
  }
  *{ box-sizing:border-box }
  html,body{
    height:100%; margin:0; background:var(--paper); color:var(--ink);
    font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Inter,Roboto,"Helvetica Neue",Arial;
  }

  /* Header */
  .topbar{
    position:fixed; left:0; right:0; top:0; z-index:3;
    min-height:64px; display:flex; align-items:center; gap:12px; flex-wrap:wrap;
    padding:10px 12px; background:#fff; border-bottom:1px solid rgba(0,0,0,.06);
    box-shadow:0 6px 18px var(--shadow);
  }
  .brand .title{font-weight:800; font-size:clamp(16px,4.6vw,20px)}
  .brand .byline{font-size:clamp(10px,2.6vw,12px); color:var(--muted); margin-top:2px}

  .reading{font-variant-numeric:tabular-nums lining-nums; letter-spacing:.02em}
  .reading .big{font-size:clamp(16px,6.4vw,28px); font-weight:800; color:var(--accent); white-space:nowrap}
  .reading .sub{font-size:clamp(10px,2.8vw,13px); color:var(--muted)}
  .reading .sep{color:#98a6a0}
  .spacer{flex:1}

  .pill{
    display:inline-flex; align-items:center; gap:.4rem; white-space:nowrap;
    padding:.4rem .6rem; border-radius:999px; background:var(--card);
    border:1px solid rgba(0,0,0,.12); box-shadow:0 6px 16px var(--shadow);
    font-size:clamp(10px,2.8vw,12px); color:var(--muted)
  }
  .gear{
    cursor:pointer; border:1px solid rgba(0,0,0,.12);
    width:38px; height:38px; border-radius:999px; display:grid; place-items:center;
    background:var(--card); color:var(--ink); box-shadow:0 6px 16px var(--shadow)
  }

  /* Endpoint-size slider */
  .control{
    display:flex; align-items:center; gap:8px; padding:.35rem .6rem;
    border-radius:999px; background:#fff; border:1px solid rgba(0,0,0,.12);
    box-shadow:0 6px 16px var(--shadow); color:#274131; font-size:12px;
  }
  .control input[type="range"]{ width:120px; }
  @media (max-width:500px){ .control input[type="range"]{ width:90px; } }

  /* Measuring stage */
  .stage{position:fixed; inset:70px 0 0 0; touch-action:none; z-index:1}
  @media (max-width:600px){ .stage{ inset:70px 0 0 0; } }
  svg{position:absolute; inset:0; width:100%; height:100%; display:block; overflow:visible; background:transparent}

  /* Instruction chips */
  .legend{
    position:fixed; left:16px; right:16px;
    bottom:calc(env(safe-area-inset-bottom,0px) + 12px);
    display:flex; gap:8px; flex-wrap:wrap; z-index:2
  }
  .legend .tag{
    padding:.35rem .6rem; border-radius:999px; background:var(--card);
    border:1px solid rgba(0,0,0,.12); color:var(--muted);
    font-size:clamp(10px,2.8vw,12px); box-shadow:0 4px 10px var(--shadow)
  }

  /* Modal — always light */
  dialog{
    border:0; border-radius:16px; background:#fff; color:var(--ink);
    box-shadow:0 20px 60px var(--shadow); width:min(720px,92vw); color-scheme:light
  }
  dialog::backdrop{background:rgba(0,0,0,.35)}
  .modal{padding:18px}
  .modal h2{margin:0 0 14px 0}

  /* Two-column grid with paired rows */
  .grid{
    display:grid; grid-template-columns:1fr 1fr; gap:14px 18px; align-items:start;
  }
  .row{display:contents;} /* allows label+input pairs to align in each column */

  .col-title{grid-column:1 / -1; font-weight:700; color:#2f4a3e; margin:6px 0 2px}

  label{font-size:12px; color:var(--muted)}
  .field{display:flex; flex-direction:column; gap:6px}
  input[type="number"], input[type="text"]{
    appearance:none; background:#fff !important; color:#0f1a17;
    border:1px solid #cfdad3; border-radius:10px; padding:.6rem .7rem;
    box-shadow:inset 0 1px 0 rgba(0,0,0,.02)
  }
  input:focus{outline:2px solid rgba(24,163,74,.35); outline-offset:2px}
  .actions{display:flex; justify-content:flex-end; gap:10px; margin-top:14px}
  .btn{border:1px solid #cfe3d7; border-radius:12px; padding:.6rem .9rem; background:#eff7f2; color:#0d2918; cursor:pointer; box-shadow:0 6px 16px var(--shadow); font-weight:700}
  .btn.alt{background:#f7faf8; color:#24332e}

  /* Measure visuals */
  .measure-line{stroke:var(--accent); stroke-width:2; stroke-linecap:round; vector-effect:non-scaling-stroke}
  .ghost{stroke:var(--accent); stroke-opacity:.35; stroke-dasharray:4 6; vector-effect:non-scaling-stroke}
  .handle{fill:var(--accent); stroke:none; opacity:1} /* solid green endpoints */
  .label{display:none} /* no mid-paper label */
</style>
</head>
<body>
  <header class="topbar" role="banner">
    <div class="brand">
      <div class="title">This Big</div>
      <div class="byline">by <span>OPULENT HARDWARE</span></div>
    </div>

    <div class="reading" id="readout">
      <div class="big">0.00 mm <span class="sep">|</span> 0.000 in</div>
      <div class="sub" id="pxinfo">0 px</div>
    </div>

    <div class="spacer"></div>

    <div class="control" aria-label="Endpoint size control">
      <span>Endpoint</span>
      <!-- default 50% -->
      <input id="handleSize" type="range" min="0.5" max="1.5" value="0.5" step="0.05" />
      <span id="handleSizeVal">50%</span>
    </div>

    <div class="pill" id="sys">DPR: <span id="dpr"></span> · Native: <span id="cssdev"></span></div>
    <button class="gear" id="openSettings" title="Calibration & settings" aria-label="Calibration & settings">⚙️</button>
  </header>

  <main class="stage" id="stage" aria-label="Touch area for 2-finger measurement">
    <svg id="overlay" viewBox="0 0 100 100" preserveAspectRatio="none" aria-hidden="true">
      <line   id="line"  class="measure-line" x1="0" y1="0" x2="0" y2="0"/>
      <line   id="ghost" class="measure-line ghost" x1="0" y1="0" x2="0" y2="0"/>
      <!-- Ellipses sized in viewBox units but computed from pixel radius so they render as true circles -->
      <ellipse id="h1" class="handle" cx="-10" cy="-10" rx="1" ry="1"/>
      <ellipse id="h2" class="handle" cx="-10" cy="-10" rx="1" ry="1"/>
      <text   id="midlabel" class="label" x="0" y="0">0.00 mm</text>
    </svg>
  </main>

  <div class="legend" aria-hidden="true">
    <div class="tag">Touch with two fingers to measure</div>
    <div class="tag">Mouse: click once, drag to place second point</div>
  </div>

  <dialog id="settings">
    <form method="dialog" class="modal">
      <h2>Calibration</h2>

      <div class="grid">
        <!-- Diagonal + DPR row (spans both columns) -->
        <div class="row">
          <div class="field" style="grid-column:1">
            <label>Display diagonal (inches)</label>
            <input type="number" step="0.01" id="diagIn" />
          </div>
          <div class="field" style="grid-column:2">
            <label>Device Pixel Ratio (browser)</label>
            <input type="number" id="dprIn" disabled />
          </div>
        </div>

        <!-- Width row: Native (left) | CSS (right) -->
        <div class="row">
          <div class="field" style="grid-column:1">
            <label>Native width (pixels)</label>
            <input type="number" step="1" id="wIn" />
          </div>
          <div class="field" style="grid-column:2">
            <label>CSS width (screen.width)</label>
            <input type="number" id="cssW" disabled />
          </div>
        </div>

        <!-- Height row: Native (left) | CSS (right) -->
        <div class="row">
          <div class="field" style="grid-column:1">
            <label>Native height (pixels)</label>
            <input type="number" step="1" id="hIn" />
          </div>
          <div class="field" style="grid-column:2">
            <label>CSS height (screen.height)</label>
            <input type="number" id="cssH" disabled />
          </div>
        </div>
      </div>

      <div class="actions">
        <button class="btn alt" value="cancel">Close</button>
        <button class="btn" id="save" value="default">Save</button>
      </div>
    </form>
  </dialog>

<script>
  // --- Calibration model ---
  const S = {
    diagIn: 15.6,          // inches (editable)
    nativeW: 1920,         // device pixels (editable)
    nativeH: 1080,         // device pixels (editable)
    dpr: window.devicePixelRatio || 1,
  };

  // Handle size model
  const HANDLE_R_BASE_PX = 10;   // base radius in *screen pixels*
  let handleScale = 0.5;         // default 50%

  // Initialize with best guesses + persisted values
  function initGuesses(){
    try{
      const cssW = window.screen.width;   // CSS px
      const cssH = window.screen.height;  // CSS px
      const dpr  = window.devicePixelRatio || 1;
      const devW = Math.round(cssW * dpr);
      const devH = Math.round(cssH * dpr);
      if (devW && devH){ S.nativeW = devW; S.nativeH = devH; }
      S.dpr = dpr;
    }catch(e){}
    const saved = localStorage.getItem('twofinger.calibration');
    if (saved) Object.assign(S, JSON.parse(saved));
    const savedScale = localStorage.getItem('twofinger.handleScale');
    if (savedScale) handleScale = Math.min(1.5, Math.max(0.5, parseFloat(savedScale)));
  }
  initGuesses();

  function save(){ localStorage.setItem('twofinger.calibration', JSON.stringify(S)); }
  function saveHandle(){ localStorage.setItem('twofinger.handleScale', String(handleScale)); }

  function ppiDevice(){ const diagPx = Math.hypot(S.nativeW, S.nativeH); return diagPx / S.diagIn; }
  function cssPxPerMM(){ return (ppiDevice() / S.dpr) / 25.4; }

  // --- Settings dialog wiring ---
  const dlg   = document.getElementById('settings');
  const diagInEl = document.getElementById('diagIn');
  const wInEl   = document.getElementById('wIn');
  const hInEl   = document.getElementById('hIn');
  const cssWEl  = document.getElementById('cssW');
  const cssHEl  = document.getElementById('cssH');
  const dprInEl = document.getElementById('dprIn');

  document.getElementById('openSettings').addEventListener('click', ()=>{
    diagInEl.value = S.diagIn;
    wInEl.value = S.nativeW;
    hInEl.value = S.nativeH;
    cssWEl.value = window.screen.width;
    cssHEl.value = window.screen.height;
    dprInEl.value = S.dpr;
    dlg.showModal();
  });

  document.getElementById('save').addEventListener('click', (e)=>{
    e.preventDefault();
    S.diagIn  = parseFloat(diagInEl.value) || S.diagIn;
    S.nativeW = parseInt(wInEl.value, 10) || S.nativeW;
    S.nativeH = parseInt(hInEl.value, 10) || S.nativeH;
    save();
    updateSystemBadge();
    render();
    dlg.close();
  });

  function updateSystemBadge(){
    document.getElementById('dpr').textContent = S.dpr.toFixed(2);
    document.getElementById('cssdev').textContent = `${S.nativeW}×${S.nativeH}`;
  }
  updateSystemBadge();

  // --- Handle size slider ---
  const handleSlider = document.getElementById('handleSize');
  const handleSizeVal = document.getElementById('handleSizeVal');
  handleSlider.value = handleScale.toFixed(2);
  handleSizeVal.textContent = Math.round(handleScale*100) + "%";
  handleSlider.addEventListener('input', ()=>{
    handleScale = parseFloat(handleSlider.value);
    handleSizeVal.textContent = Math.round(handleScale*100) + "%";
    saveHandle();
    updateGraphics();
  });

  // --- Measurement engine ---
  const stage   = document.getElementById('stage');
  const line    = document.getElementById('line');
  const ghost   = document.getElementById('ghost');
  const h1      = document.getElementById('h1');
  const h2      = document.getElementById('h2');
  const readout = document.getElementById('readout');
  const pxInfo  = document.getElementById('pxinfo');

  let a = null, b = null; // points in CSS pixels {x,y}

  function cssToViewBox(x, y){ // convert CSS px to viewBox (0..100)
    const r = stage.getBoundingClientRect();
    return { x: (x - r.left) / r.width * 100, y: (y - r.top) / r.height * 100 };
  }

  // Convert a *pixel* radius to viewBox units so circles remain circular even with preserveAspectRatio="none"
  function pixelRadiusToVB(rPx){
    const r = stage.getBoundingClientRect();
    return {
      rx: (rPx / r.width)  * 100,
      ry: (rPx / r.height) * 100
    };
  }

  function setHandleRadius(){
    const rPx = HANDLE_R_BASE_PX * handleScale;
    const {rx, ry} = pixelRadiusToVB(rPx);
    h1.setAttribute('rx', rx); h1.setAttribute('ry', ry);
    h2.setAttribute('rx', rx); h2.setAttribute('ry', ry);
  }

  function updateGraphics(){
    setHandleRadius();

    if(!a || !b){
      line.setAttribute('x1',0); line.setAttribute('y1',0);
      line.setAttribute('x2',0); line.setAttribute('y2',0);
      ghost.setAttribute('x1',0); ghost.setAttribute('y1',0);
      ghost.setAttribute('x2',0); ghost.setAttribute('y2',0);
      h1.setAttribute('cx',-10); h1.setAttribute('cy',-10);
      h2.setAttribute('cx',-10); h2.setAttribute('cy',-10);
      readout.querySelector('.big').textContent = `0.00 mm | 0.000 in`;
      pxInfo.textContent = `0 px`;
      return;
    }

    const vb1 = cssToViewBox(a.x, a.y);
    const vb2 = cssToViewBox(b.x, b.y);
    line.setAttribute('x1', vb1.x); line.setAttribute('y1', vb1.y);
    line.setAttribute('x2', vb2.x); line.setAttribute('y2', vb2.y);
    ghost.setAttribute('x1', vb1.x); ghost.setAttribute('y1', vb1.y);
    ghost.setAttribute('x2', vb2.x); ghost.setAttribute('y2', vb2.y);

    // circular endpoints (ellipses with rx/ry computed from px radius)
    h1.setAttribute('cx', vb1.x); h1.setAttribute('cy', vb1.y);
    h2.setAttribute('cx', vb2.x); h2.setAttribute('cy', vb2.y);

    // Numeric readout
    const dxCss = b.x - a.x, dyCss = b.y - a.y;
    const distPx = Math.hypot(dxCss, dyCss);
    const pxPerMM = cssPxPerMM();
    const mm = distPx / pxPerMM;
    const inches = mm / 25.4;
    readout.querySelector('.big').textContent = `${mm.toFixed(2)} mm | ${inches.toFixed(3)} in`;
    pxInfo.textContent = `${distPx.toFixed(1)} px  ·  ${pxPerMM.toFixed(3)} px/mm`;
  }

  // Touch handling (two fingers)
  let tId1 = null, tId2 = null;
  const getPos = t => ({ x:t.clientX, y:t.clientY });

  stage.addEventListener('touchstart', (e)=>{
    e.preventDefault();
    for(const t of e.changedTouches){
      if(tId1===null){ tId1 = t.identifier; a = getPos(t); }
      else if(tId2===null){ tId2 = t.identifier; b = getPos(t); }
    }
    updateGraphics();
  }, {passive:false});

  stage.addEventListener('touchmove', (e)=>{
    e.preventDefault();
    for(const t of e.changedTouches){
      if(t.identifier===tId1) a = getPos(t);
      if(t.identifier===tId2) b = getPos(t);
    }
    if(tId1!==null && tId2!==null) updateGraphics();
  }, {passive:false});

  stage.addEventListener('touchend', (e)=>{
    for(const t of e.changedTouches){
      if(t.identifier===tId1) tId1 = null;
      if(t.identifier===tId2) tId2 = null;
    }
    /* keep last reading */
  });

  // Mouse fallback: click to set first point, drag to set second
  let dragging = false;
  stage.addEventListener('mousedown', (e)=>{ a = {x:e.clientX,y:e.clientY}; b = {x:e.clientX,y:e.clientY}; dragging = true; updateGraphics(); });
  window.addEventListener('mousemove', (e)=>{ if(!dragging) return; b = {x:e.clientX,y:e.clientY}; updateGraphics(); });
  window.addEventListener('mouseup', ()=> dragging=false);

  function render(){ updateGraphics(); }
  render();
  new ResizeObserver(()=> updateGraphics()).observe(stage);
</script>
</body>
</html>
